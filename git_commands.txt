git add
git commit -m "PYR-NNNN desc ..."
git push origin -u feature/PYR-NNNN_Descr

-- Copy files from other branch to current branch
git diff --stat "$otherbranch"                  e.g. git diff --stat master
git checkout "$otherbranch" "$file"             e.g. git ckeckout master degas/DegasRegister/MapCasino.cpp
git checkout --merge "$otherbranch" "$file"     e.g. git ckeckout --merge master degas/DegasRegister/MapCasino.cpp
git diff --stat "$otherbranch"

-- Squash commits
1.  git rebase --interactive HEAD~N     - rebase
OR
    git rebase -i HEAD~N     - rebase
2.  decline PR in Bitbucket
3.  delete remote branch
    git push origin --delete branch_name

-- Check out remote branch
i.  git check out <branch_name> -- e.g. gco feature/PYR-84799-degas-mapping-of-EV-for-incomplete-bars

ii. git check out -b <local_branch_name>            -- git check out -b feature/PYR-109574_DEGAS-support-for-PBitmask
    git reset --hard origin/<remote_branch_name>    -- git reset --hard origin/feature/PYR-116560-degas-RECN-for-incomplete-bars

----------------------------------------------------------------------------------------------------------
----- GIT BRANCH
----------------------------------------------------------------------------------------------------------
-- To list the current branch in local repo
    git branch --show-current
    git name-rev --name-only HEAD
    git symbolic-ref --short HEAD
    git rev-parse --abbrev-ref HEAD

-- To list all branches in local repositories
    git branch
    git branch --list

-- To create a new branch based on <existing-branch> instead of master
    git checkout -b <new-branch> <existing-branch>
NB: By default git checkout -b will base the new-branch off the current HEAD.
    An optional additional branch parameter can be passed to git checkout.
    In the above example, <existing-branch> is passed which then bases new-branch
    off of existing-branch instead of the current HEAD

-- To create a new local branch based on current HEAD, i.e. master
    git checkout -b <new-branch>    <-- simultaneously creates and checks out <new-branch>.
                                        The -b option is a convenience flag that tells Git to run 
                                        git branch <new-branch> before running git checkout <new-branch>

    ++ under feature
        git checkout -b feature/PYR-NNNN_Descr
    ++ else
        git checkout -b PYR-NNNN_Descr
		
-- To push local branch to remote
    git push origin -u <branch_name>
	
-- To rename a local branch
    git branch -m old_branch new_branch
	
-- To rename a remote branch
    git branch -m old_branch new_branch         <-- rename branch locally
	git push origin :old_branch                 <-- delete the old_branch
	git push --set-upstream origin new_branch   <-- push the new branch and set local branch to track new rename
	
-- Deleting local Branches
    git branch -d branch_name     <-- will output an err msg if the branch hasnâ€™t been merged
    git branch -D branch_name     <-- force delete. This deletes the branch regardless of its status and without warnings, so use it judiciously

-- Deleting remote branches
    git push origin --delete branch_name
OR  git push origin :branch_name    

----------------------------------------------------------------------------------------------------------
----- GIT MERGE
----------------------------------------------------------------------------------------------------------
1.  Confirm the receiving branch
    + Execute git checkout <receiving> to switch to the receiving branch
    + Execute git status to ensure that HEAD is pointing to the correct merge-receiving branch
2.  Fetch latest remote commits
    Make sure the receiving branch and the merging branch are up-to-date with the latest remote changes
    i.e. execute git fetch or git pull
3.  Merge
    git merge <branch name> where <branch name> is the name of the branch that will be merged into the receiving branch

-- To merge master to a branch
    git checkout master
    git pull
    git submodule update
	git checkout <branch>
	git merge origin/master

----------------------------------------------------------------------------------------------------------
----- GIT LOG
----------------------------------------------------------------------------------------------------------
    git log --oneline --decorate
        --oneline flag condenses each commit to a single line
        --decorate flag makes git log display all of the references (e.g., branches, tags, etc) that point to each commit
    git log --graph --oneline --decorate
        --graph option draws an ASCII graph representing the branch structure of the commit history

Custom Formatting with --pretty=format:"<string>" option (see https://mirrors.edge.kernel.org/pub/software/scm/git/docs/git-log.html#_pretty_formats)
    git log --pretty=format:"%cn committed %h on %cd - %N"

By amount:
    git log -n      <-- display n most recent commits

By date:
    git log --after="yesterday"
same as
    git log --since="yesterday"
    git log --before="yesterday"
same as
    git log --until="yesterday"
    git log --after="2018-7-1" --before="2018-7-4"
same as    
    git log --since="2018-7-1" --until="2018-7-4"

By message:
    git log --grep="PYR-NNNN"

By file:
    git log -- file1 file2  <-- -- parameter is used to tell git log that subsequent arguments are file paths and not branch names

git log --pretty="%h - %s" --author='Junio C Hamano' --since="2008-10-01" \
   --before="2008-11-01" --no-merges -- t/

----------------------------------------------------------------------------------------------------------
----- GIT DIFF
----------------------------------------------------------------------------------------------------------
-- Compare the working directory with local repository.
    git diff HEAD [filename]
    
-- compare the working directory with index.
    git diff [filename]

-- compare the index with local repository.
    git diff --cached [filename]

-- compares working directory with index, i.e. shows the changes that are not staged yet.
    git diff

-- compares working directory with local repository. Shows the list of changes after your last commit.
    git diff HEAD

-- compares index with local repository.
-- shows the diff between your last commit and changes to be committed next.
    git diff --cached

-- Comparing files from 2 branches
    git diff br1 br2 ./path/file.cpp
e.g.  git diff master feature/PYR-84866 protocols/tracemarkers.h    

-- Compare branches
git diff br1..br2   <- two dots: indicate the diff input is the tips of both branches. The same effect happens if a space is used
git diff br1...br2  <- 3 dots: It changes branch1 into a ref of the shared common ancestor commit between the two diff inputs 

----------------------------------------------------------------------------------------------------------
----- GIT STASH
----------------------------------------------------------------------------------------------------------
    git stash list              -- list all stashes
    git stash apply             -- apply all stashes
    git stash apply stash@{2}   -- apply stash #2
    git stash apply --index     -- apply stash and restage files
    git stash drop              -- drop all stashes
    git stash pop               -- apply and drop stash
Unapplying a stash:
    git stash show -p stash@{0} | git apply -R
    alias: git config --global alias.stash-unapply '!git stash show -p | git apply -R'
Stash selected files:
    git stash push -m "message" -- file1 [file2 ... ]
    git stash push --keep-index     ** Stash modified but unstaged files. Staged|index files are left intact

OR  git stash push -p|--patch -m|--message "message"    ** then select hunks.
    NB: -p implies --keep-index. Use --no-keep-index to override


----------------------------------------------------------------------------------------------------------
----- Unstage
----------------------------------------------------------------------------------------------------------
    git reset HEAD -- fileA     <-- unstage fileA
    git unstage fileA           <-- Using alias: git config --global alias.unstage 'reset HEAD --'


----------------------------------------------------------------------------------------------------------
----- CONFLICTS
----------------------------------------------------------------------------------------------------------
Git commands that can help resolve merge conflicts
    git status          <-- help identify conflicted files
    git status | grep unmerged  <-- help identify conflicted files
    git log --merge     <-- --merge produces a log with a list of commits that conflict between the merging branches
    git diff            <-- diff helps find differences between states of a repository/files

-- To resolve conflict
	git mergetool
	- merge files from pop up window
	- save merged file. Click on Merge complete [or st like that], then
	git commit   <-- DO NOT MODIFY THE MESSAGE. JUST QUIT THE TEXT EDITOR
	git push
    

----------------------------------------------------------------------------------------------------------
----- GIT COMMIT
----------------------------------------------------------------------------------------------------------
Removing the last commit

To remove the last commit from git, you can simply run 
    git reset --hard HEAD^
    git reset --hard HEAD~1

If you are removing multiple commits from the top, you can run 
    git reset --hard HEAD~2 -- to remove the last two commits. You can increase the number to remove even more commits.

If you want to "uncommit" the commits, but keep the changes around for reworking, remove the "--hard": 
    git reset HEAD^ which will evict the commits from the branch and from the index, but leave the working tree around.

If you want to save the commits on a new branch name, then run git branch newbranchname before doing the git reset.    

----------------------------------------------------------------------------------------------------------
----- GIT ADD
----------------------------------------------------------------------------------------------------------
- Commit only part of a file:
    git add --patch [-p] <filename>

git will will begin to break down your file into what it thinks are sensible "hunks" and then prompt:
    Stage this hunk [y,n,q,a,d,/,j,J,g,s,e,?]?
        y - stage this hunk
        n - do not stage this hunk
        q - quit, do not stage this hunk nor any of the remaining ones
        a - stage this and all the remaining hunks in the file
        d - do not stage this hunk nor any of the remaining hunks in the file
        g - select a hunk to go to
        / - search for a hunk matching the given regex
        j - leave this hunk undecided, see next undecided hunk
        J - leave this hunk undecided, see next hunk
        k - leave this hunk undecided, see previous undecided hunk
        K - leave this hunk undecided, see previous hunk
        s - split the current hunk into smaller hunks
        e - manually edit the current hunk
        ? - print help

----------------------------------------------------------------------------------------------------------
----- SUBMODULES
----------------------------------------------------------------------------------------------------------
-- To check in changes in submodule
1. cd to submodule directory
2. create branch: feature/PYR-NNNNN_descr
3. git add files
4. git commit
5. git push origin master

----------------------------------------------------------------------------------------------------------
----- ALIAS
----- git config --global alias.mylast '!git log -1 --author="$(git config user.name)" --oneline --decorate HEAD'
----------------------------------------------------------------------------------------------------------
                push-branch = !git push origin -u HEAD
 pull master    pllm = !git pull --verbose --recurse-submodules=yes --auto-stash --rebase=merges
                st = !git status --branch --show-stash
                co = !git checkout
                com = !git checkout master
                ; new branch, and switch to it
 new br & sw    cob = !git checkout -b -l
                ci = !git commit
                lg = log --pretty=format:"%C(#cd9a00)%h\\%C(#0080ff)\\ <%an>\\ %C(#17b062)(%cr)\\ %d\\%C(#c0d6de)%s"    
                lg = log --pretty=format:"%C(#ffa700)%h\\%C(#0080ff)\\ <%an>\\ %C(#17b062)(%cr)\\ %d\\%C(#c0d6de)%s"    
log one line    l1 = !git lg --graph --oneline --decorate
                lgf = !git lg --name-status --graph
                l1f = !git lg --name-status

                la = !git lg --graph --decorate --numstat
log graph       gr = !git log --graph --oneline --decorate=short --branches='*'
today log       today = !git log --since=midnight --author=\"$(git config user.name)\" --graph --oneline --decorate
yesterday log   yes = !git log --since=yesterday.midnight --until=midnight --author=\"$(git config user.name)\" --graph --oneline --decorate
my log          mylog = !git log --author=\"$(git config user.name)\" --graph --oneline --decorate
my last log     mylast = !git lg -1 --author=\"$(git config user.name)\" --decorate HEAD
last log        last = !git lg -1 HEAD
                br = !git branch
                ; new branch, not switch to new branch
new br not sw   nbr = !git branch --create-reflog
                sp = !git stash pop
                sl = !git stash list
                sa = !git stash apply
                ss = !git stash save
                s = !git stash
                update-idx = !git add $(git diff --name-only --cached)
                unstage = !git reset HEAD --
                smu = !git submodule update --rebase
                dt = difftool
                mt = mergetool

                
----------------------------------------------------------------------------------------------------------
----- git bash ALIAS
----------------------------------------------------------------------------------------------------------
			 gst='git status --branch --show-stash '
			 gci='git commit '
			 gcim='git commit -m '
			 gco='git checkout '
			 gcom='git checkout master '
			 gaa='git add -A'
			 ga='git add '
-- BRANCHES
			 gbr='git branch --create-reflog '
    # delete
			 gdbr='git branch -d '
			 gdbrf='git branch -D '
			 gdrb='git push origin --delete '
    # rename a local branch
             grnbr='!git branch -m '
# logs
			 glg='git log --pretty=format:"%C(#cd9a00)%h%C(#0080ff) <%an> %C(#17b062)(%cr) %d%C(#c0d6de)%s" '
			 g1l='glg --graph --oneline --decorate '
			 glgf='glg --name-status --graph '
			 gl1f='glg --name-status '
			 gtoday='g1l --since=midnight --author=\"$(git config user.name)\" '
			 gyes='g1l --since=yesterday.midnight --until=midnight --author=\"$(git config user.name)\" '
			 gmylog='glg --author="$(git config user.name)" '
			 gmylogext='gl1f --author="$(git config user.name)" '
			 glast='gl1f --author="$(git config user.name)" -1 HEAD'
			 grflog='git log -g --abbrev-commit --pretty=format:"%C(#ff4040)%h%C(bold #00ff00) %<|(20)%gD %C(reset)%C(dim #fff600)%<(14)%cr %C(reset)%C(italic #ff00ff)%<(80,trunc)%gs %C(reset)%C(#ffbf00)(%s)"'
			 grf='git reflog --format="%C(#ff4040)%h%C(bold #00ff00) %<|(20)%gD %C(reset)%C(dim #fff600)%<(14)%cr %C(reset)%C(italic #ff00ff)%<(80,trunc)%gs %C(reset)%C(#ffbf00)(%s)"'
# stash
			 gs='git stash '
			 gsd='gs drop '
			 gsp='gs pop '
			 gsl='gs list '
			 gsa='gs apply '
			 gsp='gs push '
			 gspm='gs push --message '
			 gss='gs show -p'
			 guidx='git add $(git diff --name-only --cached) '
			 gunstage='git reset HEAD -- '
			 gamend='gci --amend --no-edit '
# revert a git stash apply
             gsunapply='git stash show -p | git apply -R'
             gsreverse='git stash show -p | git apply --reverse'
# pushes
			 gpb='git push origin -u HEAD '
			 gpub='git push origin -u HEAD '
			 gpublish='git push origin -u HEAD '
# pulls
			 gsmu='git submodule update '
			 gpull='gs && git pull --rebase=merges '
			 gget='gpull '
			 ggetm='gget && gsmu '
# to view HEAD's SHA-1 hash
             gh='!git rev-parse --verify HEAD'
             ghs='!git rev-parse --short --verify HEAD'
             ghremote='!git rev-parse --verify refs/remotes/origin/HEAD'
             ghm='!git show-ref master'
# reset
            grs='!git reset --soft '
            grh='!git reset --hard '
# merge master to branch
            gmm='!git merge origin/master '
            gmerge-base='!git merge-base '
            gmerge-basem='!git merge-base master HEAD'
